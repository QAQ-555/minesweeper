package logic

import (
	"context"
	"fmt"
	"math/rand/v2"
	"minesweeper/app/model"
	"minesweeper/app/service"
	"os"
	"strconv"

	"github.com/gogf/gf/errors/gerror"
	"github.com/google/uuid"
)

// CreateMap generates a minesweeper board with the given dimensions and number of mines.
// Parameters:
//
//	x - number of rows
//	y - number of columns
//	n - number of mines
//
// Returns:
//
//	A pointer to a 2D boolean array, where true indicates a mine and false indicates an empty cell.
//	An error if the number of mines exceeds the board size.
func CreateRealMap(x, y, n, safeX, safeY uint) ([][]bool, error) {
	if x == 0 || y == 0 {
		return nil, gerror.New("board dimensions must be greater than zero")
	}
	if n == 0 {
		return nil, gerror.New("number of mines must be greater than zero")
	}
	if n >= x*y {
		return nil, gerror.New("number of mines exceeds or equals board size")
	}
	if safeX >= x || safeY >= y {
		return nil, gerror.New("safe coordinate out of bounds")
	}

	board := make([][]bool, y)
	for i := range board {
		board[i] = make([]bool, x)
	}
	total := int(x * y)

	// 先生成 [0, total) 的下标
	indices := make([]int, 0, total-1)
	safeIndex := int(safeY*x + safeX)

	for i := 0; i < total; i++ {
		if i == safeIndex {
			continue // 跳过安全位置
		}
		indices = append(indices, i)
	}

	// 检查剩余可布雷格子数是否够
	if n > uint(len(indices)) {
		return nil, gerror.New("too many mines for available cells excluding safe cell")
	}

	// 打乱 indices
	rand.Shuffle(len(indices), func(i, j int) {
		indices[i], indices[j] = indices[j], indices[i]
	})

	// 前 n 个放雷
	for i := 0; i < int(n); i++ {
		idx := indices[i]
		row := idx / int(x)
		col := idx % int(x)
		board[row][col] = true
	}

	// 确保 safe cell 没有雷
	board[safeY][safeX] = false
	// for y, cow := range board {
	// 	for x, val := range cow {
	// 		fmt.Printf("board[%d][%d] = %t\n", y, x, val)
	// 	}
	// }
	return board, nil
}

// GetUserMap is a placeholder function that should return a client view of the map.
// Parameters:
//
// Realmap - a pointer to the real map generated by CreateRealMap
//
// Returns:
//
// A pointer to a 2D byte array representing the client view of the map.
// Currently returns nil as a placeholder.

func GetUserMap(Realmap *[][]bool) *[][]byte {
	return nil
}

func HandleLeftClick(ctx context.Context, x, y uint, c *model.Client) {
	model.Logger.Infof(ctx, "Left click received at position (%d, %d) for client %s", x, y, c.ID)

	if c.MapClient[y][x] != model.Unknown {
		model.Logger.Infof(ctx, "Cell at position (%d, %d) is not in unknown state, skipping. Current state: %d", x, y, c.MapClient[y][x])
		return
	}

	if c.MapServer[y][x] == model.MineCell {
		model.Logger.Infof(ctx, "Mine clicked at position (%d, %d). Sending boom messages.", x, y)
		msgChainId := uuid.NewString()
		count := 0
		for y, row := range c.MapServer {
			for x, val := range row {
				if val == model.MineCell {
					count++
					isEnd := (count == int(c.Map_mine_num))
					mine := model.ClickResultpayload{
						X:       uint(x),
						Y:       uint(y),
						MsgId:   msgChainId,
						IsEnd:   isEnd,
						MineNum: 10,
					}
					data, err := service.PackWebMessageJson(ctx, model.TypeBoom, mine, msgChainId)
					if err != nil {
						model.Logger.Panicf(ctx, "Failed to pack web message for boom at position (%d, %d): %v", x, y, err)
					}
					err = c.Conn.WriteMessage(1, data)
					if err != nil {
						model.Logger.Errorf(ctx, "Failed to send boom message for position (%d, %d): %v", x, y, err)
					} else {
						model.Logger.Infof(ctx, "Boom message sent for mine at position (%d, %d), message count: %d", x, y, count)
					}
				}
			}
		}
		model.Logger.Infof(ctx, "All boom messages sent.")
		return
	}

	model.Logger.Infof(ctx, "No mine at position (%d, %d). Starting recursive reveal.", x, y)
	result := make([]model.ClickResultpayload, 0)
	blankCellRecursive(ctx, x, y, c, &result)
	if len(result) != 0 {
		model.Logger.Infof(ctx, "Recursive reveal completed. Found %d cells to reveal.", len(result))
		msgChainId := uuid.NewString()
		for i := range result {
			isEnd := (i == len(result)-1)
			result[i].IsEnd = isEnd
			result[i].MsgId = msgChainId
			data, err := service.PackWebMessageJson(ctx, model.TypeResult, result[i], msgChainId)
			if err != nil {
				model.Logger.Panicf(ctx, "Failed to pack web message for revealed cell at position (%d, %d): %v", result[i].X, result[i].Y, err)
			}
			err = c.Conn.WriteMessage(1, data)
			if err != nil {
				model.Logger.Errorf(ctx, "Failed to send result message for position (%d, %d): %v", result[i].X, result[i].Y, err)
			} else {
				model.Logger.Infof(ctx, "Result message sent for revealed cell at position (%d, %d), message index: %d", result[i].X, result[i].Y, i)
			}
		}
		model.Logger.Infof(ctx, "All result messages sent.")
	} else {
		model.Logger.Infof(ctx, "Recursive reveal completed. No cells to reveal.")
	}
}

func HandleRightClick(ctx context.Context, x, y uint, c *model.Client) {
	oldValue := c.MapClient[y][x]
	var chose byte = 0
	switch oldValue {
	case model.Unknown:
		c.MapClient[y][x] = model.Flag
		model.Logger.Infof(ctx, "MapClient[%d][%d] changed from %d to %d", y, x, oldValue, model.Flag)
		chose = model.Flag
	case model.Flag:
		c.MapClient[y][x] = model.Unknown
		model.Logger.Infof(ctx, "MapClient[%d][%d] changed from %d to %d", y, x, oldValue, model.Unknown)
		chose = model.Unknown
	}
	result := model.ClickResultpayload{
		X:       x,
		Y:       y,
		MineNum: chose,
		IsEnd:   true,
	}
	data, err := service.PackWebMessageJson(ctx, model.TypeResult, result, "")
	if err != nil {
		model.Logger.Panicf(ctx, "unkonw fail!!")
	}
	err = c.Conn.WriteMessage(1, data)
	if err != nil {
		model.Logger.Errorf(ctx, "send massage fail")
	}
}

func blankCellRecursive(ctx context.Context, x, y uint, c *model.Client, result *[]model.ClickResultpayload) {
	directions := [8]struct{ X, Y int }{
		{1, 0}, {-1, 0}, {0, 1}, {0, -1},
		{1, 1}, {1, -1}, {-1, 1}, {-1, -1},
	}
	// 如果已经揭开过了，直接返回
	if c.MapClient[y][x] != model.Unknown {
		return
	}

	// 计算周围雷数
	count := getAroundMineNum(x, y, c)
	model.Logger.Infof(ctx, "around[%d,%d] mine num: %d", x, y, count)
	oldValue := c.MapClient[y][x]
	c.MapClient[y][x] = byte(count)
	model.Logger.Infof(ctx, "MapClient[%d][%d] changed from %d to %d", y, x, oldValue, byte(count))

	if count == 0 {
		// 如果周围没有雷，递归揭开周围
		for _, dir := range directions {
			newX := int(x) + dir.X
			newY := int(y) + dir.Y
			if newX < 0 || newY < 0 || newX >= int(c.Map_size_x) || newY >= int(c.Map_size_y) {
				continue
			}
			blankCellRecursive(ctx, uint(newX), uint(newY), c, result)
		}
	}

	oneResult := &model.ClickResultpayload{
		X:       x,
		Y:       y,
		MineNum: c.MapClient[y][x],
	}
	*result = append(*result, *oneResult)
}

func getAroundMineNum(x, y uint, c *model.Client) uint {
	directions := [8]struct{ X, Y int }{
		{1, 0}, {-1, 0}, {0, 1}, {0, -1},
		{1, 1}, {1, -1}, {-1, 1}, {-1, -1},
	}
	count := 0
	for _, dir := range directions {
		newX := int(x) + dir.X
		newY := int(y) + dir.Y
		if newX < 0 || newY < 0 || newX >= int(c.Map_size_x) || newY >= int(c.Map_size_y) {
			continue
		}
		if c.MapServer[newY][newX] == model.MineCell {
			count++
		}
	}
	return uint(count)
}

func getAroundFlagNum(x, y uint, c *model.Client) uint {
	directions := [8]struct{ X, Y int }{
		{1, 0}, {-1, 0}, {0, 1}, {0, -1},
		{1, 1}, {1, -1}, {-1, 1}, {-1, -1},
	}
	count := 0
	for _, dir := range directions {
		newX := int(x) + dir.X
		newY := int(y) + dir.Y
		if newX < 0 || newY < 0 || newX >= int(c.Map_size_x) || newY >= int(c.Map_size_y) {
			continue
		}
		if c.MapServer[newY][newX] == model.MineCell {
			count++
		}
	}
	return uint(count)
}
func SaveBoardWithCoords(ctx context.Context, board [][]bool) error {
	name := ctx.Value("requestID")
	filename := "default.txt"
	if str, ok := name.(string); ok && str != "" {
		filename = fmt.Sprintf("%s.txt", str)
	}

	file, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	// 横坐标头
	_, _ = file.WriteString("   ") // 缩进3空格
	for x := 0; x < len(board[0]); x++ {
		_, _ = file.WriteString(strconv.Itoa(x) + " ")
	}
	_, _ = file.WriteString("\n")

	// 每行写纵坐标和内容
	for y, row := range board {
		_, _ = file.WriteString(strconv.Itoa(y) + " ") // 写纵坐标
		if y < 10 {
			_, _ = file.WriteString(" ") // 保证对齐，两位数以上可调整
		}
		for _, cell := range row {
			if cell {
				_, _ = file.WriteString("■ ")
			} else {
				_, _ = file.WriteString("□ ")
			}
		}
		_, _ = file.WriteString("\n")
	}

	return nil
}

// 删除ctx中requestID命名的文件
func DeleteBoardFile(ctx context.Context) error {
	name := ctx.Value("requestID")
	filename := "default.txt"
	if str, ok := name.(string); ok && str != "" {
		filename = fmt.Sprintf("%s.txt", str)
	}

	err := os.Remove(filename)
	if err != nil {
		return fmt.Errorf("failed to delete file: %w", err)
	}
	return nil
}
