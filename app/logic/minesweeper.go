package logic

import (
	"context"
	"fmt"
	"math/rand/v2"
	"minesweeper/app/model"
	"os"
	"strconv"

	"github.com/gogf/gf/errors/gerror"
)

// CreateMap generates a minesweeper board with the given dimensions and number of mines.
// Parameters:
//
//	x - number of rows
//	y - number of columns
//	n - number of mines
//
// Returns:
//
//	A pointer to a 2D boolean array, where true indicates a mine and false indicates an empty cell.
//	An error if the number of mines exceeds the board size.
func CreateRealMap(x, y, n, safeX, safeY uint) ([][]bool, error) {
	if x == 0 || y == 0 {
		return nil, gerror.New("board dimensions must be greater than zero")
	}
	if n == 0 {
		return nil, gerror.New("number of mines must be greater than zero")
	}
	if n >= x*y {
		return nil, gerror.New("number of mines exceeds or equals board size")
	}
	if safeX >= x || safeY >= y {
		return nil, gerror.New("safe coordinate out of bounds")
	}

	board := make([][]bool, y)
	for i := range board {
		board[i] = make([]bool, x)
	}

	total := int(x * y)

	// 先生成 [0, total) 的下标
	indices := make([]int, 0, total-1)
	safeIndex := int(safeY*x + safeX)

	for i := 0; i < total; i++ {
		if i == safeIndex {
			continue // 跳过安全位置
		}
		indices = append(indices, i)
	}

	// 检查剩余可布雷格子数是否够
	if n > uint(len(indices)) {
		return nil, gerror.New("too many mines for available cells excluding safe cell")
	}

	// 打乱 indices
	rand.Shuffle(len(indices), func(i, j int) {
		indices[i], indices[j] = indices[j], indices[i]
	})

	// 前 n 个放雷
	for i := 0; i < int(n); i++ {
		idx := indices[i]
		row := idx / int(x)
		col := idx % int(x)
		board[row][col] = true
	}

	// 确保 safe cell 没有雷
	board[safeY][safeX] = false

	return board, nil
}

// GetUserMap is a placeholder function that should return a client view of the map.
// Parameters:
//
// Realmap - a pointer to the real map generated by CreateRealMap
//
// Returns:
//
// A pointer to a 2D byte array representing the client view of the map.
// Currently returns nil as a placeholder.

func GetUserMap(Realmap *[][]bool) *[][]byte {
	return nil
}

func HandleLeftClick(x, y uint, c *model.Client) {

	if c.MapServer[y][x] == model.MineCell {
		fmt.Printf("game.end")
	} else {
		fmt.Printf("num around :%d", getAroundMineNum(x, y, c))
	}

}

func HandleRightClick(x, y uint) {

}

func getAroundMineNum(x, y uint, c *model.Client) uint {
	directions := [8]struct{ X, Y int }{
		{1, 0}, {-1, 0}, {0, 1}, {0, -1},
		{1, 1}, {1, -1}, {-1, 1}, {-1, -1},
	}
	count := 0
	for _, dir := range directions {
		newX := int(x) + dir.X
		newY := int(y) + dir.Y
		if newX < 0 || newY < 0 || newX >= int(c.Map_size_x) || newY >= int(c.Map_size_y) {
			continue
		}
		if c.MapServer[newY][newX] == model.MineCell {
			count++
		}
	}
	return uint(count)
}

func SaveBoardWithCoords(ctx context.Context, board [][]bool) error {
	name := ctx.Value("requestID")
	filename := "default.txt"
	if str, ok := name.(string); ok && str != "" {
		filename = fmt.Sprintf("%s.txt", str)
	}

	file, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	// 横坐标头
	_, _ = file.WriteString("   ") // 缩进3空格
	for x := 0; x < len(board[0]); x++ {
		_, _ = file.WriteString(strconv.Itoa(x) + " ")
	}
	_, _ = file.WriteString("\n")

	// 每行写纵坐标和内容
	for y, row := range board {
		_, _ = file.WriteString(strconv.Itoa(y) + " ") // 写纵坐标
		if y < 10 {
			_, _ = file.WriteString(" ") // 保证对齐，两位数以上可调整
		}
		for _, cell := range row {
			if cell {
				_, _ = file.WriteString("■ ")
			} else {
				_, _ = file.WriteString("□ ")
			}
		}
		_, _ = file.WriteString("\n")
	}

	return nil
}

// 删除ctx中requestID命名的文件
func DeleteBoardFile(ctx context.Context) error {
	name := ctx.Value("requestID")
	filename := "default.txt"
	if str, ok := name.(string); ok && str != "" {
		filename = fmt.Sprintf("%s.txt", str)
	}

	err := os.Remove(filename)
	if err != nil {
		return fmt.Errorf("failed to delete file: %w", err)
	}
	return nil
}
